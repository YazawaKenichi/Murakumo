プログラムのノート

センサの位置と Rank の対応表
奥 Rank                 05, 04 | 03, 02
前 Rank 16, 15, 14, 13, 07, 06 | 01, 00, 12, 11, 10, 09

analog 配列は uint16_t と、16bit で定義されてはいるものの、実際に入る値は 0 ~ 4095 (4096 かも...) の間なので、16bit すべては使っておらず、12bit で表現できる。
例えば、すべてのセンサの値が 4095 になったとして、これを片側 8 個分だけ足すと、
4095 * 8 = 32760
すなわち、片側のセンサの最大値は 32760 であり、片側のセンサの合計値を格納する変数のサイズは unsigned 15bit (最大値 32767) でギリギリ足りるはずである。
∴片側のセンサの合計値は uint16_t で格納しておけば良さそう。

  疑問
unsigned int 16bit 型から unsigned int 16bit 型を引く、計算結果は unsigned int 16bit 型で大丈夫だろうか？
ここでは便宜的に、右側のセンサ値を AnalogR とし、左側のセンサ値を AnalogL とする。
AnalogR >= AnalogL を満たしている場合は AnalogR - AnalogL > 0 となるので、計算結果を uint16_t としても大丈夫だろう。
しかし問題は AnalogR < AnalogL となっている場合である。
この場合は AnalogL - AnalogR に計算式を変更する必要が出てきてしまう。

ここで計算結果にマイナスを許したとしよう。
例えば、計算結果を格納する変数を signed int 型にする。
すると格納できる値の範囲は -32767 ~ 0 ~ 32768 の 65536 通りとなる。
これなら万が一 AnalogL == 32760 && AnalogR == 0 を満たしてしまった場合でも、AnalogR - AnalogL = -32760 となり、オーバーフローせずに値を格納することができる。
∴全センサの計算結果を格納する変数は signed int 型で問題ないことが分かった。
  以上
  
rightmotor, leftmotor に代入する式を考える。
「片側のモータがギリギリ反転しない」を目指して作った式。
leftmotor = commspeed + direction * (1000 - commspeed) / 32768;
rightmotor = commspeed - direction * (1000 - commspeed) / 32768;
こうするとどちらか一方が「めっちゃ黒！」ってなった時に白線がある方のタイヤが止まり、めっちゃ黒な方が 100% duty で回転する。
この式は PID 制御の比例のみ制御と似た式となっている。
分かりやすく書き換えると
PGain = (AnalogL - AnalogR) * KP
という式になっており、(AnalogL - AnalogR) == 0 を満たしたときに前進するための commspeed と、0 <= leftmotor, rightmotor <= 10000 を満たすような KP の値を計算している。
二度も計算させるのは嫌なので direction * (1000 - commspeed) / 32768 は変数に格納してもいい希ガス。
この値は -32,768,000 ~ 32,767,000 の値を取るので、型は int 型。
（int の範囲 -2,147,483,648 ~ 2,147,483,648)
